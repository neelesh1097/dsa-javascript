<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary tree - basics</title>
</head>

<body>
    <h1>binary tree implementation </h1>
    <p>non linear data structure operation performed are traversing inserting sorting etc </p>
</body>
<script>
    class node {
        constructor(val) {
            this.value = val;
            this.left = null;
            this.right = null;
        }
    }
    class Bstree {
        constructor() {
            this.root = null;
        }
        isTreeEmpty() {
            return this.root === null;
        }

        makeTree(val) {
            let newNode = new node(val);
            if (this.root === null) {
                this.root = newNode;
            }
            else {
                this.insertNode(this.root, newNode);
            }

        }
        insertNode(root, newNode) {
            if (newNode.value < root.value) {
                if (root.left === null) {
                    root.left = newNode;
                } else {
                    this.insertNode(root.left, newNode);
                }
            } else {
                if (root.right === null) {
                    root.right = newNode;
                } else {
                    this.insertNode(root.right, newNode);
                }
            }
        }
        searchValue(root, val) {
            if (root === null) {
                return false;
            }
            else if (root = val) {
                return true;
            }
            else if (val < root.value) {
                return this.searchValue(root.left, val);
            }
            else if (val > root.value) {
                return this.searchValue(root.right, val);
            }
            else {
                return false;
            }
        }
        traversepreOrder(root) {
            if (root) {
                console.log(root.value);
                this.traversepreOrder(root.left);
                this.traversepreOrder(root.right);
            }

        }
        inorder(root) {
            if (root) {
                this.inorder(root.left);
                console.log(root.value);
                this.inorder(root.right);
            }
        }
        postorder(root) {
            if (root) {
                this.postorder(root.left);
                this.postorder(root.right);
                console.log(root.value);

            }
        }

        bfstraversing(){
            let queue =[];
            queue.push(this.root);
            while(queue.length){
                let current =queue.shift();
                if(current.left){
                    queue.push(current.left);
                }
                if(current.right){
                    queue.push(current.right);
                }
            }
            console.log(current.value);
        }

        minVal(root){
            if(!root.left){
                return root;
            }
            else{
                return this.minVal(root.left);
            }
        }
        maxVal(root){
            if(!root.right){
                return root;
            }
            else{
                return this.maxVal(root.right);
            }
        }
    }

    let bst = new Bstree();
    bst.makeTree(20);
    bst.makeTree(10);
    bst.makeTree(5);
    bst.makeTree(11)
    bst.makeTree(30);
    bst.makeTree(40);
    bst.makeTree(23);
    console.log(bst.isTreeEmpty());
    // bst.inorder(bst.root);
    // bst.postorder(bst.root);
    // bst.traversepreOrder(bst.root);
    bst.bfstraversing();
    console.log(bst.minVal(bst.root));
    console.log(bst.maxVal(bst.root));
    console.log(bst.searchValue(bst.root, 10));
    console.log(bst);



</script>

</html>